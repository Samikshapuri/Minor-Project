import signal 
s = signal.signal(signal.SIGINT, signal.SIG_IGN)
import json
import sys
#import matplotlib.pyplot as plt
#import seaborn as sn
import pandas as pd
from numpyencoder import NumpyEncoder
from sklearn.metrics import confusion_matrix
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn import preprocessing


# Class for the KNN classifier
class Classifier:
    # __init__ method to create the object
    def __init__(self):
        self.file_name = "C:/Users/hp/Desktop/Web D/Minor_Project/subject_description_edited.csv"
        self.df = pd.read_csv(self.file_name)
        self.df.dropna()
        return

    # Method to split the given dataset into training and testing
    def create_train_test_split(self):
        #self.raw_data = self.df.iloc[:, 6:12].values
        #print(self.raw_data)
        raw_data = self.df.iloc[:, 2:12].values
        self.X = preprocessing.normalize(raw_data)
        self.y = self.df['PCR Result'].values

        self.X_train, self.X_test, self.y_train, self.y_test = train_test_split(self.X, self.y, train_size=0.7, random_state=None)
        return

    # Method to fit the KNN model 
    def create_knn(self):
        self.knn = KNeighborsClassifier(n_neighbors=5, weights='distance')
        self.create_train_test_split()
        self.knn.fit(self.X_train, self.y_train)
        return

    # Method to display accuracy by comparing with test sets
    # def show_accuracy_knn(self):
    #     self.knn_score = str(self.knn.score(self.X, self.y) * 100) + '%'
    #     return self.knn_score

    # Method to display confusion matrix for KNN classifier
    #def display_confusion_knn(self):
    #    self.y_pred = self.knn.predict(self.X)
    #    self.cm = confusion_matrix(self.y, self.y_pred)
    #    plt.figure(figsize=(7,5))
    #    sn.heatmap(self.cm, annot=True)
    #    plt.xlabel('Predicted')
    #    plt.ylabel('Truth')
    #    plt.show()
    #    return

    # Method to create SVM classifier
    # def create_svm(self):
    #     self.svm = SVC(C=1, gamma=10)
    #     self.svm.fit(self.X_train, self.y_train)
    #     return

    # # Method to show the accuracy SVM
    # def show_accuracy_svm(self):
    #     self.svm_score = str(self.svm.score(self.X, self.y) * 100) + '%'
    #     return self.svm_score

    # Method to display confusion matrix for SVM classifier
    # def display_confusion_svm(self):
    #     self.y_pred = self.svm.predict(self.X)
    #     self.cm = confusion_matrix(self.y, self.y_pred)
    #     plt.figure(figsize=(7,5))
    #     sn.heatmap(self.cm, annot=True)
    #     plt.xlabel('Predicted')
    #     plt.ylabel('Truth')
    #     plt.show()
    #     return

    # Method to read the data from the JSON file generated by the backend
    def read_json(self):
        f = open("C:/Users/hp/Desktop/Web D/Minor_Project/Backend/newPredictor.json")
        self.file_data = json.load(f)
        del self.file_data['name']
        return

    def predict_knn(self):
        file_df = pd.DataFrame([self.file_data])
        file_df = file_df.iloc[:, 2:12].values
        self.prediction = self.knn.predict(file_df)[0]
        if file_df[0][-3] == 1 or file_df[0][-2] == 1:
            self.prediction = 1
        return

    def write_json(self):
        self.file_data['prediction'] = self.prediction
        #with open('predicted.json','w') as f:
        #    json.dump(self.file_data, f, indent=4, cls=NumpyEncoder)
        print(self.prediction)
        sys.stdout.flush()
        return


# Driver Function
def main():
    classifier = Classifier()
    classifier.create_train_test_split()
    classifier.create_knn()
    #classifier.create_svm()
    #print(f'Accuracy of KNN is: {classifier.show_accuracy_knn()}')
    #classifier.display_confusion_knn()

    #print(f'Accuracy of SVM is: {classifier.show_accuracy_svm()}')
    #classifier.display_confusion_svm()    
    classifier.read_json()
    classifier.predict_knn()
    classifier.write_json()
    return


if __name__ == '__main__':
    main()
    signal.signal(signal.SIGINT, s)
